{
  "statements": [
    {
      "query": "MATCH ((n:EC2SecurityGroup)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID})) where EXISTS(n.exposed_internet) WITH n LIMIT $LIMIT_SIZE REMOVE n.exposed_internet, n.exposed_internet_type, n.publicContext return COUNT(*) as TotalCompleted",
      "iterative": true,
      "iterationsize": 100
    },
    {
      "query": "MATCH (:IpRange{id: '0.0.0.0/0'})-[:MEMBER_OF_IP_RULE]->(ip_perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(group:EC2SecurityGroup)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE (ip_perm.fromport in $PUBLIC_PORTS) AND (ip_perm.toport in $PUBLIC_PORTS) SET group.exposed_internet = true,(CASE WHEN NOT 'unrestricted_inbound_traffic_ipv4' IN  coalesce(group.exposed_internet_type , []) THEN group END).exposed_internet_type = coalesce(group.exposed_internet_type , []) + 'unrestricted_inbound_traffic_ipv4';",
      "iterative": false
    },
    {
      "query": "MATCH (:Ipv6Range{id: '::/0'})-[:MEMBER_OF_IP_RULE]->(ip_perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(group:EC2SecurityGroup)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE (ip_perm.fromport in $PUBLIC_PORTS) AND (ip_perm.toport in $PUBLIC_PORTS) SET group.exposed_internet = true,(CASE WHEN NOT 'unrestricted_inbound_traffic_ipv6' IN  coalesce(group.exposed_internet_type , []) THEN group END).exposed_internet_type = coalesce(group.exposed_internet_type , []) + 'unrestricted_inbound_traffic_ipv6';",
      "iterative": false
    },
    {
      "query": "MATCH (:IpRange{id: '0.0.0.0/0'})-[:MEMBER_OF_IP_RULE]->(:IpPermissionEgress)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(group:EC2SecurityGroup)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) SET group.exposed_internet = true,(CASE WHEN NOT 'egress_security_group_ipv4' IN  coalesce(group.exposed_internet_type , []) THEN group END).exposed_internet_type = coalesce(group.exposed_internet_type , []) + 'egress_security_group_ipv4';",
      "iterative": false
    },
    {
      "query": "MATCH (:Ipv6Range{id: '::/0'})-[:MEMBER_OF_IP_RULE]->(:IpPermissionEgress)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(group:EC2SecurityGroup)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) SET group.exposed_internet = true,(CASE WHEN NOT 'egress_security_group_ipv6' IN  coalesce(group.exposed_internet_type , []) THEN group END).exposed_internet_type = coalesce(group.exposed_internet_type , []) + 'egress_security_group_ipv6';",
      "iterative": false
    },
    {
      "query": "MATCH (group:EC2SecurityGroup)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE NOT EXISTS ((group)<-[:MEMBER_OF_EC2_SECURITY_GROUP]-(:AWSVpc)) SET group.exposed_internet = true,(CASE WHEN NOT 'vpc_none' IN  coalesce(group.exposed_internet_type , []) THEN group END).exposed_internet_type = coalesce(group.exposed_internet_type , []) + 'vpc_none';",
      "iterative": false
    },
    {
      "query": "MATCH (group:EC2SecurityGroup)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE group.exposed_internet = true WITH group OPTIONAL MATCH (cidr)-[:MEMBER_OF_IP_RULE]->(rule:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(group) WHERE (cidr:IpRange AND cidr.id = '0.0.0.0/0' AND rule.fromport IN $PUBLIC_PORTS) OR (cidr:Ipv6Range AND cidr.id = '::/0' AND rule.fromport IN $PUBLIC_PORTS) WITH group, collect(DISTINCT {port: toString(rule.fromport), protocol: rule.ipprotocol, ipRanges: CASE WHEN cidr:IpRange THEN [cidr.id] WHEN cidr:Ipv6Range THEN [cidr.id] ELSE [] END, direction: 'inbound'}) as inboundRules OPTIONAL MATCH (cidr2)-[:MEMBER_OF_IP_RULE]->(egress:IpPermissionEgress)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(group) WHERE (cidr2:IpRange AND cidr2.id = '0.0.0.0/0') OR (cidr2:Ipv6Range AND cidr2.id = '::/0') WITH group, inboundRules, collect(DISTINCT {port: toString(egress.fromport), protocol: egress.ipprotocol, ipRanges: CASE WHEN cidr2:IpRange THEN [cidr2.id] WHEN cidr2:Ipv6Range THEN [cidr2.id] ELSE [] END, direction: 'egress'}) as egressRules SET group.publicContext = apoc.convert.toJson([{resource: group.id, resourceType: 'aws-networking-ec2-securitygroup', context: [{securityGroupId: group.id, groupName: group.groupname, vpcId: group.vpcid, exposureTypes: group.exposed_internet_type, inboundRules: inboundRules, egressRules: egressRules}]}])",
      "iterative": false
    }
  ],
  "name": "aws ec2 security group internet exposure"
}
