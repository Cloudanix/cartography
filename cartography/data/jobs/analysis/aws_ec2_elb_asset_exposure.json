{
  "statements": [
    {
      "query": "MATCH ((n)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID})) where EXISTS(n.exposed_internet) AND n:LoadBalancer OR n:LoadBalancerV2 WITH n LIMIT $LIMIT_SIZE REMOVE n.exposed_internet, n.exposed_internet_type, n.publicContext return COUNT(*) as TotalCompleted",
      "iterative": true,
      "iterationsize": 100
    },
    {
      "query": "MATCH ((n:ELBListener)<-[:ELB_LISTENER]-(:LoadBalancer)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID})) where EXISTS(n.exposed_internet) WITH n LIMIT $LIMIT_SIZE REMOVE n.exposed_internet, n.exposed_internet_type, n.publicContext return COUNT(*) as TotalCompleted",
      "iterative": true,
      "iterationsize": 100
    },
    {
      "query": "MATCH ((n:ELBV2Listener)<-[:ELBV2_LISTENER]-(:LoadBalancerV2)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID})) where EXISTS(n.exposed_internet) WITH n LIMIT $LIMIT_SIZE REMOVE n.exposed_internet, n.exposed_internet_type, n.publicContext return COUNT(*) as TotalCompleted",
      "iterative": true,
      "iterationsize": 100
    },
    {
      "query": "MATCH (cidr:Ipv6Range{range:'::/0'})-[:MEMBER_OF_IP_RULE]->(perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:MEMBER_OF_EC2_SECURITY_GROUP]-(elbv2:LoadBalancerV2{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WITH elbv2,perm MATCH (elbv2)-[:ELBV2_LISTENER]->(listener:ELBV2Listener) WHERE listener.port>=perm.fromport AND listener.port<=perm.toport SET elbv2.exposed_internet = true,(CASE WHEN NOT 'unrestricted_inbound_traffic_ipv6' IN coalesce(elbv2.exposed_internet_type , []) THEN elbv2 END).exposed_internet_type = coalesce(elbv2.exposed_internet_type , []) + 'unrestricted_inbound_traffic_ipv6'",
      "iterative": false
    },
    {
      "query": "MATCH (cidr:IpRange{range:'0.0.0.0/0'})-[:MEMBER_OF_IP_RULE]->(perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:MEMBER_OF_EC2_SECURITY_GROUP]-(elbv2:LoadBalancerV2{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WITH elbv2,perm MATCH (elbv2)-[:ELBV2_LISTENER]->(listener:ELBV2Listener) WHERE listener.port>=perm.fromport AND listener.port<=perm.toport SET elbv2.exposed_internet = true,(CASE WHEN NOT 'unrestricted_inbound_traffic_ipv4' IN  coalesce(elbv2.exposed_internet_type , []) THEN elbv2 END).exposed_internet_type = coalesce(elbv2.exposed_internet_type , []) + 'unrestricted_inbound_traffic_ipv4'",
      "iterative": false
    },
    {
      "query": "MATCH (cidr:IpRange{range:'0.0.0.0/0'})-[:MEMBER_OF_IP_RULE]->(perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:SOURCE_SECURITY_GROUP]-(elb:LoadBalancer{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WITH elb,perm MATCH (elb)-[:ELB_LISTENER]->(listener:ELBListener) WHERE listener.port>=perm.fromport AND listener.port<=perm.toport SET elb.exposed_internet = true,(CASE WHEN NOT 'unrestricted_inbound_traffic_ipv4' IN coalesce(elb.exposed_internet_type , []) THEN elb END).exposed_internet_type = coalesce(elb.exposed_internet_type , []) + 'unrestricted_inbound_traffic_ipv4'",
      "iterative": false
    },
    {
      "query": "MATCH (cidr:Ipv6Range{range:'::/0'})-[:MEMBER_OF_IP_RULE]->(perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:SOURCE_SECURITY_GROUP]-(elb:LoadBalancer{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WITH elb,perm MATCH (elb)-[:ELB_LISTENER]->(listener:ELBListener) WHERE listener.port>=perm.fromport AND listener.port<=perm.toport SET elb.exposed_internet = true,(CASE WHEN NOT 'unrestricted_inbound_traffic_ipv6' IN  coalesce(elb.exposed_internet_type , []) THEN elb END).exposed_internet_type = coalesce(elb.exposed_internet_type , []) + 'unrestricted_inbound_traffic_ipv6'",
      "iterative": false
    },
    {
      "query": "MATCH (elbv2:LoadBalancerV2{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) SET elbv2.exposed_internet = true,(CASE WHEN NOT 'scheme' IN coalesce(elbv2.exposed_internet_type , []) THEN elbv2 END).exposed_internet_type = coalesce(elbv2.exposed_internet_type , []) + 'scheme';",
      "iterative": false
    },
    {
      "query": "MATCH (elb:LoadBalancer{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) SET elb.exposed_internet = true,(CASE WHEN NOT 'scheme' IN coalesce(elb.exposed_internet_type , []) THEN elb END).exposed_internet_type = coalesce(elb.exposed_internet_type , []) + 'scheme';",
      "iterative": false
    },
    {
      "query": "MATCH (cidr:Ipv6Range{range:'::/0'})-[:MEMBER_OF_IP_RULE]->(perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:MEMBER_OF_EC2_SECURITY_GROUP]-(elbv2:LoadBalancerV2{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WITH elbv2,perm MATCH (elbv2)-[:ELBV2_LISTENER]->(listener:ELBV2Listener) WHERE listener.port>=perm.fromport AND listener.port<=perm.toport SET listener.exposed_internet = true,(CASE WHEN NOT 'loadbalancer_unrestricted_inbound_traffic_ipv6' IN  coalesce(listener.exposed_internet_type , []) THEN listener END).exposed_internet_type = coalesce(listener.exposed_internet_type , []) + 'loadbalancer_unrestricted_inbound_traffic_ipv6'",
      "iterative": false
    },
    {
      "query": "MATCH (cidr:IpRange{range:'0.0.0.0/0'})-[:MEMBER_OF_IP_RULE]->(perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:MEMBER_OF_EC2_SECURITY_GROUP]-(elbv2:LoadBalancerV2{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WITH elbv2,perm MATCH (elbv2)-[:ELBV2_LISTENER]->(listener:ELBV2Listener) WHERE listener.port>=perm.fromport AND listener.port<=perm.toport SET listener.exposed_internet = true,(CASE WHEN NOT 'loadbalancer_unrestricted_inbound_traffic_ipv4' IN coalesce(listener.exposed_internet_type , []) THEN listener END).exposed_internet_type = coalesce(listener.exposed_internet_type , []) + 'loadbalancer_unrestricted_inbound_traffic_ipv4'",
      "iterative": false
    },
    {
      "query": "MATCH (cidr:IpRange{range:'0.0.0.0/0'})-[:MEMBER_OF_IP_RULE]->(perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:SOURCE_SECURITY_GROUP]-(elb:LoadBalancer{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WITH elb,perm MATCH (elb)-[:ELB_LISTENER]->(listener:ELBListener) WHERE listener.port>=perm.fromport AND listener.port<=perm.toport SET listener.exposed_internet = true,(CASE WHEN NOT 'loadbalancer_unrestricted_inbound_traffic_ipv4' IN coalesce(listener.exposed_internet_type , []) THEN listener END).exposed_internet_type = coalesce(listener.exposed_internet_type , []) + 'loadbalancer_unrestricted_inbound_traffic_ipv4'",
      "iterative": false
    },
    {
      "query": "MATCH (cidr:Ipv6Range{range:'::/0'})-[:MEMBER_OF_IP_RULE]->(perm:IpPermissionInbound)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:SOURCE_SECURITY_GROUP]-(elb:LoadBalancer{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WITH elb,perm MATCH (elb)-[:ELB_LISTENER]->(listener:ELBListener) WHERE listener.port>=perm.fromport AND listener.port<=perm.toport SET listener.exposed_internet = true,(CASE WHEN NOT 'loadbalancer_unrestricted_inbound_traffic_ipv6' IN  coalesce(listener.exposed_internet_type , []) THEN listener END).exposed_internet_type = coalesce(listener.exposed_internet_type , []) + 'loadbalancer_unrestricted_inbound_traffic_ipv6'",
      "iterative": false
    },
    {
      "query": "MATCH (elbv2_listener:ELBV2Listener)<-[:ELBV2_LISTENER]-(:LoadBalancerV2{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) SET elbv2_listener.exposed_internet = true,(CASE WHEN NOT 'loadbalancer_scheme' IN coalesce(elbv2_listener.exposed_internet_type , []) THEN elbv2_listener END).exposed_internet_type = coalesce(elbv2_listener.exposed_internet_type , []) + 'loadbalancer_scheme';",
      "iterative": false
    },
    {
      "query": "MATCH (elb_listener:ELBListener)<-[:ELB_LISTENER]-(:LoadBalancer{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) SET elb_listener.exposed_internet = true, (CASE WHEN NOT 'loadbalancer_scheme' IN coalesce(elb_listener.exposed_internet_type , []) THEN elb_listener END).exposed_internet_type = coalesce(elb_listener.exposed_internet_type , []) + 'loadbalancer_scheme';",
      "iterative": false
    },
    {
      "query": "MATCH (route:EC2Route{destination_ipv6_cidr_block: '::/0'})<-[:MEMBER_OF_ROUTE_TABLE]-(:EC2RouteTable)-[:HAS_ASSOCIATION]->(:EC2RouteTableAssociation)<-[:HAS_EXPLICIT_ASSOCIATION|HAS_IMPLICIT_ASSOCIATION]-(:EC2Subnet)<-[:SUBNET]-(elb:LoadBalancer{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE route.gateway_id STARTS WITH 'igw-' SET elb.exposed_internet = true,(CASE WHEN NOT 'public_subnet_ipv6' IN  coalesce(elb.exposed_internet_type , []) THEN elb END).exposed_internet_type = coalesce(elb.exposed_internet_type , []) + 'public_subnet_ipv6';",
      "iterative": false
    },
    {
      "query": "MATCH (route:EC2Route{destination_cidr_block: '0.0.0.0/0'})<-[:MEMBER_OF_ROUTE_TABLE]-(:EC2RouteTable)-[:HAS_ASSOCIATION]->(:EC2RouteTableAssociation)<-[:HAS_EXPLICIT_ASSOCIATION|HAS_IMPLICIT_ASSOCIATION]-(:EC2Subnet)<-[:SUBNET]-(elb:LoadBalancer{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE route.gateway_id STARTS WITH 'igw-' SET elb.exposed_internet = true,(CASE WHEN NOT 'public_subnet_ipv4' IN  coalesce(elb.exposed_internet_type , []) THEN elb END).exposed_internet_type = coalesce(elb.exposed_internet_type , []) + 'public_subnet_ipv4';",
      "iterative": false
    },
    {
      "query": "MATCH (route:EC2Route{destination_ipv6_cidr_block: '::/0'})<-[:MEMBER_OF_ROUTE_TABLE]-(:EC2RouteTable)-[:HAS_ASSOCIATION]->(:EC2RouteTableAssociation)<-[:HAS_EXPLICIT_ASSOCIATION|HAS_IMPLICIT_ASSOCIATION]-(:EC2Subnet)<-[:SUBNET]-(elbv2:LoadBalancerV2{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE route.gateway_id STARTS WITH 'igw-' SET elbv2.exposed_internet = true,(CASE WHEN NOT 'public_subnet_ipv6' IN  coalesce(elbv2.exposed_internet_type , []) THEN elbv2 END).exposed_internet_type = coalesce(elbv2.exposed_internet_type , []) + 'public_subnet_ipv6';",
      "iterative": false
    },
    {
      "query": "MATCH (route:EC2Route{destination_cidr_block: '0.0.0.0/0'})<-[:MEMBER_OF_ROUTE_TABLE]-(:EC2RouteTable)-[:HAS_ASSOCIATION]->(:EC2RouteTableAssociation)<-[:HAS_EXPLICIT_ASSOCIATION|HAS_IMPLICIT_ASSOCIATION]-(:EC2Subnet)<-[:SUBNET]-(elbv2:LoadBalancerV2{scheme: 'internet-facing'})<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE route.gateway_id STARTS WITH 'igw-' SET elbv2.exposed_internet = true,(CASE WHEN NOT 'public_subnet_ipv4' IN  coalesce(elbv2.exposed_internet_type , []) THEN elbv2 END).exposed_internet_type = coalesce(elbv2.exposed_internet_type , []) + 'public_subnet_ipv4';",
      "iterative": false
    },
    {
      "query": "MATCH (elbv2:LoadBalancerV2)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE elbv2.exposed_internet = true WITH elbv2 OPTIONAL MATCH (elbv2)-[:ELBV2_LISTENER]->(listener:ELBV2Listener) WITH elbv2, collect(DISTINCT {port: toString(listener.port), protocol: listener.protocol, sslPolicy: listener.sslpolicy, exposureTypes: listener.exposed_internet_type}) as listeners SET elbv2.publicContext = apoc.convert.toJson([{resource: elbv2.id, resourceType: 'aws-networking-elb-loadbalancerv2', context: [{lbArn: elbv2.id, dnsName: elbv2.dnsname, scheme: elbv2.scheme, type: elbv2.type, exposureTypes: elbv2.exposed_internet_type, listeners: listeners}]}])",
      "iterative": false
    },
    {
      "query": "MATCH (elb:LoadBalancer)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE elb.exposed_internet = true WITH elb OPTIONAL MATCH (elb)-[:ELB_LISTENER]->(listener:ELBListener) WITH elb, collect(DISTINCT {port: toString(listener.port), protocol: listener.protocol, exposureTypes: listener.exposed_internet_type}) as listeners SET elb.publicContext = apoc.convert.toJson([{resource: elb.id, resourceType: 'aws-networking-elb-loadbalancer', context: [{lbName: elb.name, dnsName: elb.dnsname, scheme: elb.scheme, exposureTypes: elb.exposed_internet_type, listeners: listeners}]}])",
      "iterative": false
    },
    {
      "query": "MATCH (listener:ELBV2Listener)<-[:ELBV2_LISTENER]-(elbv2:LoadBalancerV2)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE listener.exposed_internet = true WITH listener, elbv2 SET listener.publicContext = apoc.convert.toJson([{resource: listener.id, resourceType: 'aws-networking-elb-elbv2listener', context: [{listenerArn: listener.id, port: toString(listener.port), protocol: listener.protocol, sslPolicy: listener.sslpolicy, loadBalancerArn: elbv2.id, loadBalancerDns: elbv2.dnsname, loadBalancerScheme: elbv2.scheme, exposureTypes: listener.exposed_internet_type}]}])",
      "iterative": false
    },
    {
      "query": "MATCH (listener:ELBListener)<-[:ELB_LISTENER]-(elb:LoadBalancer)<-[:RESOURCE]-(:AWSAccount{id: $AWS_ID})<-[:OWNER]-(:AWSOrganization{id: $ORGANIZATION_ID})<-[:OWNER]-(:CloudanixWorkspace{id: $WORKSPACE_ID}) WHERE listener.exposed_internet = true WITH listener, elb SET listener.publicContext = apoc.convert.toJson([{resource: listener.id, resourceType: 'aws-networking-elb-elblistener', context: [{listenerId: listener.id, port: toString(listener.port), protocol: listener.protocol, loadBalancerName: elb.name, loadBalancerDns: elb.dnsname, loadBalancerScheme: elb.scheme, exposureTypes: listener.exposed_internet_type}]}])",
      "iterative": false
    }
  ],
  "name": "AWS ec2 elb internet exposure"
}
